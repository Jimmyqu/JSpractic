<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>Title</title>
    <style>
      #box {
        overflow: scroll;
      }
    </style>
  </head>
  <body style="margin: 0">
    <div id="box">
      <img
        style="display: none"
        id="img"
        src="https://p1.meituan.net/movie/77717de09967c29cd5b3d1f76309ac841254.png"
        alt=""
      />
      <img
        style="display: none"
        id="newImage"
        src="./asset/img.png"
        alt=""
      />

      <canvas width="375" height="550" id="canvas"></canvas>
      <div class="btn">
          <button id="add">+</button>
          <button id="der">-</button>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/4.2.0/fabric.min.js"></script>
    <script>
      let isScale = false;
      let box = document.getElementById("box");
      let add = document.getElementById("add");
      let der = document.getElementById("der");
      let canvas = document.getElementById("canvas");
      const imgElement = document.getElementById("img");
      const ctx = canvas.getContext("2d");
      const hammerTest = new Hammer(box);

      var fcanvas = new fabric.Canvas("canvas");

      var rect = new fabric.Rect({
            top : 0, //距离画布上边的距离
            left : 0, //距离画布左侧的距离，单位是像素
            width : 20, //矩形的宽度
            height : 500, //矩形的高度
            fill : '#000', //填充的颜色
            stroke: '#000', // 边框原色
            opacity: 0.5, // 图片透明度
            rx: 10, //圆角半径
            ry: 10 //圆角半径
        });

        fcanvas.add(rect)

      fcanvas.selection = false;
      for (let i = 50; i < 375; i += 25) { 
        for (let j = 1; j < 500; j += 25) {
            let textInstance = new fabric.Text('2', {
                left: 5, // 图片相对画布的左侧距离
                top: j, // 图片相对画布的顶部距离
                fontFamily: 'helvetica',
                scaleX: 0.4,
                scaleY: 0.4,
                fill: '#fff'
            });
          fcanvas.add(textInstance);
          let imgInstance = new fabric.Image(imgElement, {
            left: i, // 图片相对画布的左侧距离
            top: j, // 图片相对画布的顶部距离
            angle: 0, // 图片旋转角度
            opacity: 0.85, // 图片透明度
            // 这里可以通过scaleX和scaleY来设置图片绘制后的大小，这里为原来大小的一半
            scaleX: 0.5,
            scaleY: 0.5,
            selectable: false,
          });
          fcanvas.add(imgInstance);
        }
      }

      let isPinch = false  
      hammerTest.get("pinch").set({ enable: true });
      hammerTest.on("pinch", (e) => {
        let isPinch = true
        if (e.scale > 1 && e.scale < 2) {
          fcanvas.setZoom(e.scale);
          let isPinch = false  
        }
      });

      var isPanning = false;
      let sx,sy
        fcanvas.on('mouse:up', function (e) {
            panning = false;
        });

        fcanvas.on('mouse:down', function (e) {
            isPanning = true;
            sx= e.pointer.x
            sy= e.pointer.y
        });
        fcanvas.on('mouse:move', function (e) {
            if(fcanvas.viewportTransform[4]>(fcanvas.width- 50)){
                fcanvas.viewportTransform[4] = fcanvas.width- 50
            }
            if(fcanvas.viewportTransform[4]<0 && Math.abs(fcanvas.viewportTransform[4])>(fcanvas.width- 50)){
                fcanvas.viewportTransform[4] = -(fcanvas.width/2)
            }


            if(fcanvas.viewportTransform[5]>fcanvas.height -50){
                fcanvas.viewportTransform[5] = fcanvas.height -50
            }
            if(fcanvas.viewportTransform[5]<0 && Math.abs(fcanvas.viewportTransform[5])>(fcanvas.height- 50)){
                fcanvas.viewportTransform[5] = -(fcanvas.height/2)
            }

            if (isPanning && e) {
                let mx = e.pointer.x - sx
                let my = e.pointer.y - sy
                var delta = new fabric.Point(mx, my);
                fcanvas.relativePan(delta);
                sx = e.pointer.x
                sy = e.pointer.y
            }
        });
     
    fcanvas.on("mouse:down", function (options) {
        console.log(fcanvas);
        console.log(options.target);
        if (isPinch) return
        if (!options.target) return;
        if (!options.target.isSelect) {
        options.target.setElement(document.getElementById("newImage"));
        options.target.isSelect = true;
        } else {
        options.target.isSelect = false;
        options.target.setElement(document.getElementById("img"));
        }
    });

    add.addEventListener('click', ()=>{
        console.log(fcanvas.getZoom())
        if(fcanvas.getZoom()<2){
            fcanvas.setZoom(fcanvas.getZoom() * 1.1);
        }
    })
    der.addEventListener('click', ()=>{
        if(fcanvas.getZoom()>0.8){
            fcanvas.setZoom(fcanvas.getZoom()/1.1);
        }
    })
    </script>
  </body>
</html>
