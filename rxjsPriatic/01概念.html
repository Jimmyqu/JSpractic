<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]>      <html class="no-js"> <!--<![endif]-->
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <title></title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="stylesheet" href="">
        
    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="#">upgrade your browser</a> to improve your experience.</p>
        <![endif]-->
        <h1>异步编程的问题</h1>
        <ul>
            <li>竞态条件 (Race Condition)</li>
            <p>比如说我们发了一个 Request 更新使用者资料，然后我们又立即发送另一个 Request 取得使用者资料，这时第一个 Request 和第二个 Request 先后顺序就会影响到最终接收到的结果不同，这就是 Race Condition。</p>
            <li>内存泄漏 (Memory Leak)</li>
            <p>例如做 SPA (Single Page Application) 网站时，我们是透过 JavaScript 来达到切换页面的内容，这时如果有对 DOM 注册监听事件，而没有在适当的时机点把监听的事件移除，就有可能造成 Memory Leak。比如说在 A 页面监听 body 的 scroll 事件，但页面切换时，没有把 scroll 的监听事件移除。</p>
            <li>复杂的状态 (Complex State)</li>
            <p>当有非同步行为时，应用程式的状态就会变得非常复杂！比如说我们有一支付费用户才能播放的视频，首先可能要先抓取这部视频的资讯，接着我们要在播放时去验证使用者是否有权限播放，而使用者也有可能再按下播放后又立即按了取消，而这些都是非同步执行，这时就会各种复杂的状态需要处理</p>
            <li>例外处理 (Exception Handling)</li>
            <p> try/catch 可以捕捉同步的例外，但非同步的程式就没这么容易，尤其当我们的非同步行为很复杂时，这个问题就愈加明显</p>
        </ul>

        <h1>RXJS模式是观察者模式 和 迭代器模式</h1>
        <p>Observable 其实就是这两个 Pattern（模式） 思想的结合，Observable 具备生产者推送资料的特性，同时能像序列，拥有序列处理资料的方法(map, filter...)！</p>
        
        <h1>rxjs核心三个重点</h1>
        <p>Observable 可以被订阅(subscribe)，或说可以被观察，而订阅 Observable 的事件又称为 观察者(Observer)。
            观察者是一个具有三个方法(method)的事件，每当 Observable 发生事件时，便会呼叫观察者相对应的方法。</p>
     
        <ul>
            <li>Observer(观察者)</li>
            <p>Observable通常是被rxjs创建 Rx.Observable.fromEvent(box,'click')</p>
            <pre>var observer = {
                next: function(value) {
                    console.log(value);
                },
                error: function(error) {
                    console.log(error)
                },
                complete: function() {
                    console.log('complete')
                }
            }</pre>
            通常只需要next时可以简写为
            <pre>var observer = (data)=>console.log(data)</pre>
            <p>然后ob_box.subscribe(observer)</p>
            <li>Subject(订阅者)</li>
            <li>Schedulers(操作符)</li>
        </ul>
        <script src="https://unpkg.com/@reactivex/rxjs@6.0.0-beta.1/dist/global/Rx.umd.js"></script>
        <div id='box' style="width: 100px;height: 100px;background-color: rebeccapurple;position: relative;">
        </div>
        
        <script async defer>
            const box=document.getElementById('box')
            const body=document.body

            // let timer$ = Rx.Observable.interval(1000)
            // let timer_observer = (data)=>console.log(data)
            // timer$.subscribe(timer_observer)
        </script>
    </body>
</html>