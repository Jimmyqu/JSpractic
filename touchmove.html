<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Title</title>
    <link
      href="https://unpkg.com/tailwindcss@^2/dist/tailwind.min.css"
      rel="stylesheet"
    />
    <style>
      .box {
        width: 100px;
        height: 50px;
        top: 10px;
        left: 10px;
        background-color: red;
        position: absolute;
      }
      .box1 {
        width: 100px;
        height: 50px;
        top: 150px;
        left: 175px;
        background-color: red;
        position: absolute;
      }
    </style>
  </head>
  <body>
    <h4>test</h4>
    <div class="flex container">
      <div class="w-8/12 bg-green-100 h-96 relative">
        <div class="box"></div>
        <div class="box1 box"></div>
      </div>
    </div>
    <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.js"></script>

    <script>
      class EnvetBus {
        constructor() {
          this.events = {};
        }

        on(type, callback) {
          if (!this.events[type]) {
            this.events[type] = [];
          }
          this.events[type].push(callback);
        }

        emit(type, ...rags) {
          this.events[type].map((callback) => {
            callback(...rags);
          });
        }
      }

      class Dragify {
        constructor(el) {
          this.el = el;
          this.envirment = this.isTouch()
            ? ["touchstart", "touchmove", "touchend"]
            : ["mousedown", "mousemove", "mouseup"];
          this.init();
          this.watcher = new EnvetBus();
        }

        init() {
          this.el.addEventListener(this.envirment[0], (e) => {
            const event = this._getEventInfo(e);
            const parent = this.el.offsetParent;
            const pX = parent.offsetLeft;
            const pY = parent.offsetTop;
            const pWidth = parent.offsetWidth;
            const pHeight = parent.offsetHeight;
            const boxWidth = this.el.offsetWidth;
            const boxHeight = this.el.offsetHeight;
            const startX = this.el.offsetLeft;
            const startY = this.el.offsetTop;
            // console.log(event.clientX, event.clientY); // 指针相对于屏幕
            // console.log(this.el.offsetParent); //offsetParent 很有用，因为 offsetTop 和 offsetLeft 都是相对于其内边距边界的
            // console.log(this.el.offsetLeft, this.el.offsetTop);
            this.watcher.emit("start", this.el);
            const foo = (e) => {
              const documentEvent = this._getEventInfo(e);
              console.log(documentEvent.clientX, event.clientX)
              const moveX = documentEvent.clientX - event.clientX;
              const moveY = documentEvent.clientY - event.clientY;
              this.el.style.left = startX + moveX + "px";
              this.el.style.top = startY + moveY + "px";
              if (this.el.offsetLeft < 0) {
                this.el.style.left = 0 + "px";
              }
              if (this.el.offsetTop < 0) {
                this.el.style.top = 0 + "px";
              }
              if (this.el.offsetLeft > pX + pWidth - boxWidth) {
                this.el.style.left = pX + pWidth - boxWidth + "px";
              }
              if (this.el.offsetTop > pHeight - boxHeight) {
                this.el.style.top = pHeight - boxHeight + "px";
              }
              this.el.style.zIndex = 19911125;
              this.watcher.emit("move");
            };
            document.addEventListener(this.envirment[1], foo);

            const goo = () => {
              this.watcher.emit("end");
              document.removeEventListener(this.envirment[1], foo);
              document.removeEventListener(this.envirment[2], goo);
            };
            document.addEventListener(this.envirment[2], goo);
          });
        }

        on() {
          this.watcher.on.apply(this.watcher, arguments);
        }

        isTouch(e) {
          return (
            "ontouchstart" in window ||
            (window.DocumentTouch &&
              document instanceof window.DocumentTouch) ||
            navigator.maxTouchPoints > 0 ||
            window.navigator.msMaxTouchPoints > 0
          );
        }

        _getEventInfo(e) {
          return this.isTouch() ? e.targetTouches[0] : e;
        }
      }

      class RefLine {
        constructor(options = {}) {
          this.options = Object.assign(
            {
              gap: 2,
            },
            options
          );
        }

        /**
         * @param dragNode {Element} 拖拽元素的原生node
         * @param checkNodes {String|Element} 选择器 或者 原生node集合
         */
        check(dragNode, checkNodes) {
          checkNodes =
            typeof checkNodes === "string"
              ? document.querySelectorAll(checkNodes)
              : checkNodes;
          let dragRect = dragNode.getBoundingClientRect();

          this.uncheck();
          Array.from(checkNodes).forEach((item) => {
            item.classList.remove("ref-line-active");

            if (item === dragNode) return;
            let { top, height, bottom, left, width, right } =
              item.getBoundingClientRect();
            let dragWidthHalf = dragRect.width / 2;
            let itemWidthHalf = width / 2;
            let dragHeightHalf = dragRect.height / 2;
            let itemHeightHalf = height / 2;

            let conditions = {
              top: [
                // xt-top
                {
                  isNearly: this._isNearly(dragRect.top, top),
                  lineNode: lines.xt,
                  lineValue: top,
                  dragValue: top,
                },
                // xt-bottom
                {
                  isNearly: this._isNearly(dragRect.bottom, top),
                  lineNode: lines.xt,
                  lineValue: top,
                  dragValue: top - dragRect.height*1.5,
                },
                // xc
                {
                  isNearly: this._isNearly(
                    dragRect.top + dragHeightHalf,
                    top + itemHeightHalf
                  ),
                  lineNode: lines.xc,
                  lineValue: top + itemHeightHalf,
                  dragValue: top + itemHeightHalf - dragHeightHalf,
                },
                // xb-top
                {
                  isNearly: this._isNearly(dragRect.bottom, bottom),
                  lineNode: lines.xb,
                  lineValue: bottom,
                  dragValue: bottom - dragRect.height*1.5,
                },
                // xb-bottom
                {
                  isNearly: this._isNearly(dragRect.top, bottom),
                  lineNode: lines.xb,
                  lineValue: bottom,
                  dragValue: bottom- dragRect.height/2,
                },
              ],

              left: [
                // yl-left
                {
                  isNearly: this._isNearly(dragRect.left, left),
                  lineNode: lines.yl,
                  lineValue: left,
                  dragValue: left,
                },
                // yl-right
                {
                  isNearly: this._isNearly(dragRect.right, left),
                  lineNode: lines.yl,
                  lineValue: left,
                  dragValue: left - dragRect.width,
                },
                // yc
                {
                  isNearly: this._isNearly(
                    dragRect.left + dragWidthHalf,
                    left + itemWidthHalf
                  ),
                  lineNode: lines.yc,
                  lineValue: left + itemWidthHalf,
                  dragValue: left + itemWidthHalf - dragWidthHalf,
                },
                // yr-left
                {
                  isNearly: this._isNearly(dragRect.right, right),
                  lineNode: lines.yr,
                  lineValue: right,
                  dragValue: right - dragRect.width,
                },
                // yr-right
                {
                  isNearly: this._isNearly(dragRect.left, right),
                  lineNode: lines.yr,
                  lineValue: right,
                  dragValue: right,
                },
              ],
            };

            for (let key in conditions) {
              // 遍历符合的条件并处理
              conditions[key].forEach((condition) => {
                if (!condition.isNearly) return;

                item.classList.add("ref-line-active");
                dragNode.style[key] = `${condition.dragValue}px`;
                condition.lineNode.style[key] = `${condition.lineValue}px`;
                condition.lineNode.show();
              });
            }
          });
        }

        uncheck() {
          Object.values(lines).forEach((item) => item.hide());
          Array.from(document.querySelectorAll(".ref-line-active")).forEach(
            (item) => item.classList.remove("ref-line-active")
          );
        }

        _isNearly(dragValue, targetValue) {
          return Math.abs(dragValue - targetValue) <= this.options.gap;
        }
      }

      let lines = {
        xt: null,
        xc: null,
        xb: null,
        yl: null,
        yc: null,
        yr: null,
      };

      // 置入参考线
      for (let p in lines) {
        let node = (lines[p] = document.createElement("div"));

        node.classList.add("ref-line", p);
        node.style.cssText = `display:none;opacity:0.7;position:absolute;background:#4DAEFF;z-index:199111250;${
          p[0] === "x"
            ? "width:100%;height:1px;left:0;"
            : "width:1px;height:100%;top:0;"
        }`;

        // 挂上一些辅助方法
        node.show = function () {
          this.style.display = "block";
        };
        node.hide = function () {
          this.style.display = "none";
        };
        node.isShow = function () {
          return this.style.display !== "none";
        };
        document.body.appendChild(node);
      }

      const box = new Dragify(document.querySelector(".box"));
      let refLine = new RefLine();

      box.on("start", () => {});

      box.on("move", () => {
        refLine.check(document.querySelector(".box"), ".box1");
      });

      box.on("end", () => {
        refLine.uncheck();
      });

      $(".box").dblclick(() => {
        // 设置可编辑
        $(".box").attr("contenteditable", "true");
      });
    </script>
  </body>
</html>
